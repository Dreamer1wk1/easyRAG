# EasyRAG 向量检索服务架构文档

## 1. 系统概述

EasyRAG 是小绿书平台的向量检索服务，负责文本的向量化存储、相似度检索和重排序。

### 技术栈
- **框架**: Flask
- **向量数据库**: Chroma (本地持久化)
- **嵌入模型**: BAAI/bge-small-zh-v1.5
- **重排序模型**: BAAI/bge-reranker-v2-m3
- **服务发现**: Nacos

---

## 2. 核心架构

```
┌─────────────────────────────────────────────────────────────────────┐
│                     Java AI Service (调用方)                         │
└─────────────────────────────────────────────────────────────────────┘
           │              │              │              │
           ▼              ▼              ▼              ▼
      ┌────────┐    ┌────────┐    ┌────────┐    ┌────────┐
      │  /add  │    │/search │    │/delete │    │/rerank │
      └────────┘    └────────┘    └────────┘    └────────┘
           │              │              │              │
           ▼              ▼              ▼              ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         Flask App (app.py)                          │
└─────────────────────────────────────────────────────────────────────┘
           │              │              │              │
           ▼              ▼              ▼              ▼
┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│ VectorStore  │  │ VectorStore  │  │ VectorStore  │  │  Reranker    │
│ process_text │  │ similarity_  │  │   delete     │  │   Service    │
│              │  │   search     │  │              │  │              │
└──────────────┘  └──────────────┘  └──────────────┘  └──────────────┘
           │              │              │              │
           ▼              ▼              ▼              ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    Chroma Vector Database                           │
│                   (本地持久化: ./comment_vectors)                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 3. 文本插入流程 (`/add`)

### 3.1 流程图

```
POST /add
{
  "text": "xiaomi 17 pro max 具有 6.9 英寸屏幕...",
  "metadata": {
    "filterKey": "content_18_isComment_false",
    "filterKeyForDel": "content_18_isComment_false"
  }
}
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│ Step 1: 文本长度判断                                                 │
│   if len(text) < MIN_CHUNK_LENGTH (300):                            │
│       → 不分块，直接存储                                             │
│   else:                                                              │
│       → 根据 CHUNK_STRATEGY 选择分块策略                             │
└─────────────────────────────────────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│ Step 2: 文本分块（根据策略）                                         │
│                                                                      │
│  ┌─────────────┐   ┌─────────────┐   ┌─────────────┐               │
│  │    char     │   │  semantic   │   │   hybrid    │               │
│  │  字符分块    │   │  语义分块    │   │  混合分块    │               │
│  └─────────────┘   └─────────────┘   └─────────────┘               │
│        │                 │                 │                        │
│        ▼                 ▼                 ▼                        │
│  RecursiveChar-    SemanticChunker   根据长度自动选择:              │
│  TextSplitter      (计算句子相似度)   <1000: 字符分块                │
│  chunk_size=500                       >=1000: 语义分块              │
│  overlap=100                                                        │
└─────────────────────────────────────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│ Step 3: 向量化 + 存储                                                │
│   Embedding Model: BAAI/bge-small-zh-v1.5                           │
│   Storage: Chroma (collection: "comment")                           │
│   每个 chunk 携带相同的 metadata                                     │
└─────────────────────────────────────────────────────────────────────┘
        │
        ▼
返回: {"status": "success", "count": 1}
```

### 3.2 字符分块配置

```python
RecursiveCharacterTextSplitter(
    chunk_size=500,          # 每块最大 500 字符（约 250 汉字）
    chunk_overlap=100,       # 块之间重叠 100 字符
    separators=[
        "\n\n",              # 1. 段落分隔（最高优先级）
        "\n",                # 2. 换行
        "。",                # 3. 句号
        "！",                # 4. 感叹号
        "？",                # 5. 问号
        "；",                # 6. 分号
        "……",               # 7. 省略号
        "...",               # 8. 英文省略号
        "，",                # 9. 逗号
        " ",                 # 10. 空格
        ""                   # 11. 按字符切
    ]
)
```

### 3.3 分块策略对比

| 策略 | 配置值 | 特点 | 适用场景 |
|------|--------|------|----------|
| 字符分块 | `char` | 快速、无额外依赖 | 默认，适合大多数场景 |
| 语义分块 | `semantic` | 保持语义完整，需要计算嵌入 | 长文档、质量优先 |
| 混合分块 | `hybrid` | 根据长度自动选择 | 文本长度差异大 |

---

## 4. 文本查询流程 (`/search`)

### 4.1 流程图

```
POST /search
{
  "query": "xiaomi 17 pro max 特点",
  "topK": 5,
  "filter": {"filterKey": "content_18_isComment_false"}
}
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│ Step 1: 查询向量化                                                   │
│   Embedding Model: BAAI/bge-small-zh-v1.5                           │
│   query → [0.12, -0.34, 0.56, ...] (384 维向量)                      │
└─────────────────────────────────────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│ Step 2: 向量相似度检索                                               │
│   方法: similarity_search_with_relevance_scores                     │
│   ✓ 支持 metadata 过滤 (filter)                                     │
│   ✓ 返回相关性分数 (0-1，越大越相关)                                  │
└─────────────────────────────────────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│ Step 3: 格式化返回                                                   │
│   每条结果包含:                                                      │
│   - text: 文本内容                                                   │
│   - score: 相关性分数 (0-1)                                         │
│   - metadata: 原始元数据                                             │
└─────────────────────────────────────────────────────────────────────┘
        │
        ▼
返回:
{
  "results": [
    {
      "text": "6.9英寸超级像素直屏...",
      "score": 0.8234,
      "metadata": {"filterKey": "content_18_isComment_false", "score": 0.8234}
    }
  ]
}
```

### 4.2 相关性分数说明

| 分数范围 | 含义 | 建议 |
|----------|------|------|
| 0.7 - 1.0 | 高度相关 | 可直接使用 |
| 0.4 - 0.7 | 部分相关 | 需要 Reranker 精排 |
| 0.0 - 0.4 | 低相关/不相关 | 考虑过滤 |

---

## 5. 重排序流程 (`/rerank`)

### 5.1 流程图

```
POST /rerank
{
  "query": "xiaomi 17 pro max 特点",
  "documents": ["文档1...", "文档2...", "文档3..."],
  "topK": 5
}
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│ Step 1: 构建 Query-Document 对                                       │
│   pairs = [                                                          │
│     ["xiaomi 17 pro max 特点", "文档1..."],                          │
│     ["xiaomi 17 pro max 特点", "文档2..."],                          │
│     ...                                                              │
│   ]                                                                  │
└─────────────────────────────────────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│ Step 2: Reranker 模型计算相关性                                       │
│   Model: BAAI/bge-reranker-v2-m3 (多语言)                            │
│   Device: CUDA (如可用) / CPU                                        │
│   FP16: 启用 (加速)                                                  │
│   scores = reranker.compute_score(pairs, normalize=True)            │
└─────────────────────────────────────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│ Step 3: 按分数降序排序，返回 Top-K                                    │
└─────────────────────────────────────────────────────────────────────┘
        │
        ▼
返回:
{
  "results": [
    {"index": 2, "score": 0.95, "text": "文档3..."},
    {"index": 0, "score": 0.87, "text": "文档1..."},
    {"index": 1, "score": 0.45, "text": "文档2..."}
  ]
}
```

### 5.2 Reranker vs 向量检索

| 对比项 | 向量检索 | Reranker |
|--------|----------|----------|
| 速度 | 快 (毫秒级) | 较慢 (50-200ms) |
| 精度 | 一般 (语义近似) | 高 (交叉注意力) |
| 用途 | 粗排 (召回) | 精排 (Top-K) |

---

## 6. API 接口汇总

### 6.1 文本操作

| 接口 | 方法 | 描述 |
|------|------|------|
| `/add` | POST | 添加单条文本 |
| `/add_batch` | POST | 批量添加文本 |
| `/delete` | POST | 根据 metadata 删除 |
| `/search` | POST | 相似度检索 |
| `/rerank` | POST | 重排序 |

### 6.2 问答接口

| 接口 | 方法 | 描述 |
|------|------|------|
| `/ask` | POST | 同步问答 |
| `/ask-stream` | POST | 流式问答 (SSE) |

---

## 7. 配置说明

### 7.1 环境变量 (.env)

```bash
# 嵌入模型
EMBEDDING_MODEL=BAAI/bge-small-zh-v1.5

# 向量存储
VECTOR_DIR=./comment_vectors

# 文本分块
CHUNK_SIZE=500              # 每块最大字符数
CHUNK_OVERLAP=100           # 重叠字符数
CHUNK_STRATEGY=char         # 分块策略: char/semantic/hybrid
MIN_CHUNK_LENGTH=300        # 低于此长度不分块

# Reranker
RERANKER_MODEL=BAAI/bge-reranker-v2-m3
RERANKER_USE_FP16=True

# Nacos
NACOS_SERVER_ADDR=47.119.40.192:8848
SERVICE_NAME=easyrag-service
SERVICE_PORT=5000
```

### 7.2 Nacos 服务注册

服务启动后自动注册到 Nacos：
- 服务名: `easyrag-service`
- 端口: `5000`
- 心跳间隔: `5s`

---

## 8. 启动方式

```bash
# 激活虚拟环境
.venv\Scripts\activate

# 启动服务
python app.py
```

**注意**: 使用 `python app.py` 而非 `flask run`，因为 Nacos 注册逻辑在 `if __name__ == '__main__'` 块中。

---

## 9. 依赖项

```
flask==3.1.0
langchain-chroma>=0.1.0
langchain-huggingface>=0.0.3
langchain-text-splitters>=0.0.1
langchain-experimental>=0.0.47  # 语义分块需要
FlagEmbedding>=1.2.0            # Reranker 需要
nacos-sdk-python<3.0.0
python-dotenv>=1.0.0
```
